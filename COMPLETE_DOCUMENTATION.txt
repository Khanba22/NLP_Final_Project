================================================================================
        TECHNICAL PRODUCT SUMMARIZER - COMPLETE DOCUMENTATION
================================================================================

Created: 2024
Purpose: AI-Powered Technical Product Analysis and Comparison System
Version: 1.0

================================================================================
                            SECTION 1: OVERVIEW
================================================================================

1.1 WHAT IS THIS SOFTWARE?
---------------------------
The Technical Product Summarizer is an advanced Natural Language Processing 
(NLP) application that automatically analyzes technical product descriptions 
and generates structured, organized summaries. It combines state-of-the-art 
machine learning models with rule-based extraction to provide:

- Structured product summaries with specifications
- Multi-product comparisons with side-by-side analysis
- Quality evaluation metrics (ROUGE and BLEU scores)
- Custom training capabilities for domain-specific summarization
- Professional-grade evaluation tools for summary quality assessment

1.2 KEY APPLICATIONS
--------------------
This software is designed for:

A) E-Commerce Platforms
   - Automatically generate consistent product descriptions
   - Create comparison tables for similar products
   - Extract key specifications from manufacturer descriptions

B) Tech Review Websites
   - Compare multiple products systematically
   - Generate structured reviews with pros/cons
   - Maintain consistency across product reviews

C) Market Research
   - Analyze product specifications at scale
   - Compare competitive products
   - Extract market trends from product descriptions

D) Product Management
   - Quickly understand product features
   - Compare competitive offerings
   - Generate product briefs for stakeholders

E) Consumer Guidance
   - Provide clear, structured product information
   - Help consumers make informed decisions
   - Match products to specific use cases

1.3 CORE FEATURES
-----------------
Feature 1: Technical Product Summarization
   - Input: Long, unstructured product descriptions
   - Output: Structured summary with:
     * Product name and category
     * Key technical specifications
     * Advantages (pros)
     * Disadvantages (cons)
     * Best use case recommendations
     * Price range estimation

Feature 2: Multi-Product Comparison
   - Compare 2-5 products simultaneously
   - Generate specification comparison tables
   - Identify common features and differences
   - Provide use-case matching for each product

Feature 3: Quality Evaluation
   - Measure summary quality using industry-standard metrics
   - ROUGE scores (Recall-Oriented Understudy for Gisting Evaluation)
   - BLEU scores (Bilingual Evaluation Understudy)
   - Overall quality scoring system

Feature 4: Training & Fine-tuning
   - Built-in dataset of technical products
   - Capability to fine-tune models on custom data
   - Training pipeline with configurable parameters
   - Support for domain-specific customization

1.4 TECHNICAL APPROACH
----------------------
The system uses a hybrid approach combining:

1) Deep Learning Models
   - Pre-trained transformer models (BART)
   - Sequence-to-sequence architecture
   - Attention mechanisms for context understanding

2) Rule-Based Extraction
   - Pattern matching for specifications
   - Keyword-based analysis for pros/cons
   - Category detection using domain knowledge

3) Statistical Methods
   - Frequency analysis for keyword extraction
   - N-gram overlap for quality metrics
   - Tokenization and normalization

1.5 SYSTEM ARCHITECTURE
-----------------------
The application follows a modern web architecture:

Frontend: HTML/CSS/JavaScript
   - Single-page application with tabs
   - Real-time API communication
   - Responsive design for all devices

Backend: FastAPI (Python)
   - RESTful API endpoints
   - Asynchronous request handling
   - Dependency injection pattern

AI/ML Layer: Transformers + PyTorch
   - Model inference engine
   - Training pipeline
   - Evaluation metrics calculation

Data Layer: In-memory dataset
   - Structured JSON data
   - Sample product database
   - Training data management


================================================================================
                    SECTION 2: LIBRARIES AND DEPENDENCIES
================================================================================

2.1 WEB FRAMEWORK LIBRARIES
----------------------------

A) FastAPI (Core Framework)
   Purpose: Modern, high-performance web framework for building APIs
   
   Why FastAPI?
   - Automatic API documentation (Swagger UI)
   - Fast performance (built on Starlette and Pydantic)
   - Type hints for automatic validation
   - Asynchronous support for concurrent requests
   - Easy dependency injection
   
   Usage in this project:
   - Defines all API endpoints (/technical-summarize, /compare-products, etc.)
   - Handles HTTP requests and responses
   - Manages application lifecycle
   - Serves the frontend HTML

B) Uvicorn (ASGI Server)
   Purpose: Lightning-fast ASGI server for running FastAPI applications
   
   Features:
   - Asynchronous request handling
   - WebSocket support
   - Hot-reload during development
   - Production-ready performance
   
   Usage:
   - Runs the FastAPI application
   - Handles incoming HTTP connections
   - Manages worker processes

C) Pydantic & Pydantic-Settings
   Purpose: Data validation and settings management
   
   Features:
   - Automatic type validation
   - JSON serialization
   - Settings from environment variables
   - Schema generation
   
   Usage:
   - Defines request/response models (TechnicalSummaryResponse, etc.)
   - Validates input data
   - Manages application configuration

D) Jinja2
   Purpose: Template engine for rendering HTML
   
   Usage:
   - Renders the index.html template
   - Passes context variables to frontend

E) Python-Multipart
   Purpose: Handles file uploads in forms
   
   Usage:
   - Processes PDF file uploads
   - Handles multipart form data

2.2 NLP AND MACHINE LEARNING LIBRARIES
---------------------------------------

A) Transformers (Hugging Face)
   Purpose: State-of-the-art NLP models and tools
   Version: Latest with PyTorch support
   
   What it does:
   - Provides pre-trained models (BART, T5, GPT, etc.)
   - Tokenization (converting text to numbers)
   - Model inference (running predictions)
   - Training utilities
   
   Models used:
   - facebook/bart-large-cnn: Summarization model
     * 400M parameters
     * Trained on CNN/DailyMail dataset
     * Bidirectional encoder + autoregressive decoder
   
   Key Components:
   - AutoTokenizer: Converts text â†” token IDs
   - AutoModelForSeq2SeqLM: Sequence-to-sequence model
   - Pipeline: High-level API for common tasks
   
   Usage in project:
   - Loads BART model for summarization
   - Tokenizes product descriptions
   - Generates summaries via model.generate()
   - Handles model inference

B) PyTorch (torch)
   Purpose: Deep learning framework
   
   Features:
   - Tensor operations (like NumPy but GPU-capable)
   - Automatic differentiation
   - Neural network building blocks
   - GPU acceleration
   
   Usage:
   - Runs transformer models
   - Handles device management (CPU/CUDA)
   - Performs inference with torch.no_grad()
   - Manages model parameters

C) LangChain & LangChain-Community
   Purpose: Framework for developing LLM-powered applications
   
   Features:
   - Prompt templates
   - Chain of operations
   - LLM integration utilities
   - Document processing
   
   Usage:
   - Creates structured prompts (PromptTemplate)
   - Manages prompt engineering
   - Future integration with LLMs for enhanced analysis

D) NLTK (Natural Language Toolkit)
   Purpose: Classic NLP library with linguistic tools
   
   Features:
   - Sentence tokenization
   - Word tokenization
   - Stopwords lists
   - Stemming and lemmatization
   
   Usage:
   - sent_tokenize(): Splits text into sentences
   - word_tokenize(): Splits text into words
   - stopwords.words('english'): Common word filtering
   
   Why needed?
   - Rule-based extraction requires sentence splitting
   - Keyword extraction needs stopword filtering
   - Extractive summarization uses sentence scoring

2.3 EVALUATION METRICS LIBRARIES
---------------------------------

A) rouge-score
   Purpose: Calculate ROUGE metrics for summary evaluation
   
   What is ROUGE?
   ROUGE (Recall-Oriented Understudy for Gisting Evaluation) measures
   overlap between generated and reference summaries.
   
   Metrics calculated:
   - ROUGE-1: Unigram (single word) overlap
   - ROUGE-2: Bigram (two-word phrase) overlap
   - ROUGE-L: Longest Common Subsequence
   
   Each metric provides:
   - Precision: % of generated content that's relevant
   - Recall: % of reference content captured
   - F-measure: Harmonic mean of precision and recall
   
   Usage:
   - rouge_scorer.RougeScorer: Calculates scores
   - Evaluates summary quality objectively
   - Compares against ground truth summaries

B) evaluate
   Purpose: Hugging Face's evaluation library
   
   Features:
   - Standardized evaluation metrics
   - Integration with Hugging Face ecosystem
   - Easy metric computation
   
   Usage:
   - Additional evaluation capabilities
   - Metric standardization

2.4 TRAINING AND OPTIMIZATION LIBRARIES
----------------------------------------

A) datasets (Hugging Face)
   Purpose: Dataset loading and processing
   
   Features:
   - Fast data loading
   - Built-in preprocessing
   - Memory-efficient streaming
   - Easy train/test splits
   
   Usage:
   - Converts product data to HuggingFace Dataset format
   - Enables efficient batching
   - Handles tokenization in batches

B) accelerate
   Purpose: Simplifies distributed training
   
   Features:
   - Multi-GPU training
   - Mixed precision training
   - Gradient accumulation
   - Device management
   
   Usage:
   - Handles device placement automatically
   - Optimizes training performance
   - Enables efficient model training

C) peft (Parameter-Efficient Fine-Tuning)
   Purpose: Efficient model fine-tuning techniques
   
   Features:
   - LoRA (Low-Rank Adaptation)
   - Prefix tuning
   - Adapter layers
   - Reduces training costs
   
   Usage:
   - Enables fine-tuning with limited resources
   - Reduces number of trainable parameters
   - Maintains model quality

2.5 UTILITY LIBRARIES
---------------------

A) PyPDF2
   Purpose: PDF file processing
   
   Features:
   - Extract text from PDFs
   - Handle multiple pages
   - Parse PDF structure
   
   Usage:
   - extract_text_from_pdf(): Reads uploaded PDFs
   - Converts PDF content to plain text
   - Enables PDF product description analysis

B) scikit-learn
   Purpose: Machine learning utilities
   
   Features:
   - Data preprocessing
   - Evaluation metrics
   - Train/test splitting
   - Statistical analysis
   
   Usage:
   - Additional ML utilities
   - Data analysis tools
   - Metric calculations

C) pandas
   Purpose: Data manipulation and analysis
   
   Features:
   - DataFrame operations
   - CSV reading/writing
   - Data aggregation
   - Statistical analysis
   
   Usage:
   - to_dataframe(): Converts product data
   - Data analysis and visualization
   - Dataset manipulation

D) python-dotenv
   Purpose: Environment variable management
   
   Features:
   - Loads .env files
   - Environment configuration
   - Secrets management
   
   Usage:
   - Manages API keys securely
   - Configuration management
   - Environment-specific settings


================================================================================
                  SECTION 3: TECHNICAL ARCHITECTURE
================================================================================

3.1 PROJECT STRUCTURE
---------------------

NLP_Text_Summariser/
â”‚
â”œâ”€â”€ app/                          # Main application package
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ main.py                   # FastAPI application entry point
â”‚   â”‚
â”‚   â”œâ”€â”€ api/                      # API layer
â”‚   â”‚   â”œâ”€â”€ endpoints.py          # API route definitions
â”‚   â”‚   â””â”€â”€ schemas.py            # Pydantic models for requests/responses
â”‚   â”‚
â”‚   â”œâ”€â”€ core/                     # Core application logic
â”‚   â”‚   â”œâ”€â”€ config.py             # Configuration management
â”‚   â”‚   â””â”€â”€ lifespan.py           # Application lifecycle management
â”‚   â”‚
â”‚   â”œâ”€â”€ services/                 # Business logic layer
â”‚   â”‚   â”œâ”€â”€ summarizer.py         # Base summarization service
â”‚   â”‚   â””â”€â”€ technical_summarizer.py # Technical product summarizer
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                     # Data layer
â”‚   â”‚   â””â”€â”€ product_dataset.py    # Product dataset management
â”‚   â”‚
â”‚   â”œâ”€â”€ evaluation/               # Evaluation metrics
â”‚   â”‚   â””â”€â”€ metrics.py            # ROUGE, BLEU calculations
â”‚   â”‚
â”‚   â”œâ”€â”€ training/                 # Model training
â”‚   â”‚   â””â”€â”€ trainer.py            # Training pipeline
â”‚   â”‚
â”‚   â””â”€â”€ utils/                    # Utility functions
â”‚       â””â”€â”€ file_handler.py       # File processing utilities
â”‚
â”œâ”€â”€ templates/                    # Frontend templates
â”‚   â””â”€â”€ index.html                # Main UI
â”‚
â”œâ”€â”€ static/                       # Static assets
â”‚   â””â”€â”€ style.css                 # Styling
â”‚
â”œâ”€â”€ requirements.txt              # Python dependencies
â”œâ”€â”€ README.md                     # Project documentation
â””â”€â”€ demo_usage.py                 # Demo/testing script

3.2 DATA FLOW ARCHITECTURE
---------------------------

Step-by-Step Request Processing:

1. USER ACTION
   User enters product description in web interface
   â†“

2. FRONTEND (JavaScript)
   - Captures form data
   - Creates FormData object
   - Sends POST request to /technical-summarize
   â†“

3. FASTAPI ROUTER (endpoints.py)
   - Receives HTTP request
   - Validates input using Pydantic schemas
   - Calls get_technical_summarizer() dependency
   â†“

4. TECHNICAL SUMMARIZER SERVICE (technical_summarizer.py)
   - extract_structured_summary() called
   - Processes product description
   â†“

5. TEXT SUMMARIZATION
   a) summarize_to_text()
      - Tokenizes input text
      - Calls _safe_summarize()
      - Generates base summary using BART model
   
   b) Model Inference
      - Converts text to token IDs
      - Runs through BART encoder-decoder
      - Beam search for best summary
      - Decodes tokens back to text
   â†“

6. RULE-BASED EXTRACTION
   Parallel processing of:
   
   a) _extract_specifications()
      - Pattern matching for specs
      - Keyword-based extraction
   
   b) _extract_pros_cons()
      - Sentiment-based analysis
      - Identifies positive/negative points
   
   c) _determine_category()
      - Keyword matching for product type
   
   d) _extract_product_name()
      - Capitalized word extraction
   
   e) _determine_use_case()
      - Context analysis
   
   f) _estimate_price_range()
      - Keyword-based price estimation
   â†“

7. STRUCTURED OUTPUT
   - Combines all extracted information
   - Creates dictionary with all fields
   - Returns structured summary
   â†“

8. RESPONSE GENERATION
   - FastAPI converts to TechnicalSummaryResponse
   - JSON serialization
   - HTTP response sent to frontend
   â†“

9. FRONTEND DISPLAY
   - JavaScript receives JSON
   - Updates DOM with structured data
   - Displays formatted summary to user

3.3 MODEL ARCHITECTURE
----------------------

BART (Bidirectional and Auto-Regressive Transformers)
Model: facebook/bart-large-cnn (400M parameters)

Architecture Components:

1. ENCODER (Bidirectional)
   Input: Product description tokens
   
   Layers: 12 transformer layers
   - Multi-head self-attention (16 heads)
   - Feed-forward networks
   - Layer normalization
   - Residual connections
   
   Process:
   - Reads entire input simultaneously
   - Creates contextualized representations
   - Captures semantic meaning

2. DECODER (Auto-Regressive)
   Output: Summary tokens (one at a time)
   
   Layers: 12 transformer layers
   - Masked multi-head self-attention
   - Encoder-decoder attention
   - Feed-forward networks
   
   Process:
   - Generates one token at a time
   - Attends to encoder outputs
   - Uses previously generated tokens

3. GENERATION STRATEGY
   Method: Beam Search (num_beams=4)
   
   Parameters:
   - max_length: 200 tokens
   - min_length: 50 tokens
   - length_penalty: 2.0 (favor longer summaries)
   - early_stopping: True
   
   Process:
   - Maintains 4 candidate sequences
   - Selects highest probability tokens
   - Prunes low-probability branches
   - Returns best final sequence

3.4 API ENDPOINTS SPECIFICATION
--------------------------------

Endpoint 1: GET /
   Purpose: Serve main UI
   Response: HTML page
   
Endpoint 2: GET /health
   Purpose: Health check
   Response: {"status": "healthy"}
   
Endpoint 3: POST /technical-summarize
   Purpose: Generate structured product summary
   
   Input:
   - text: str (product description) OR
   - file: UploadFile (PDF)
   
   Output: TechnicalSummaryResponse
   {
     "product_name": str,
     "category": str,
     "summary": str,
     "key_specs": dict,
     "pros": list[str],
     "cons": list[str],
     "best_for": str,
     "price_range": str,
     "original_length": int
   }
   
Endpoint 4: POST /compare-products
   Purpose: Compare multiple products
   
   Input:
   - texts: list[str] (2-5 product descriptions) OR
   - files: list[UploadFile] (2-5 PDFs)
   
   Output: ProductComparisonResponse
   {
     "product_count": int,
     "same_category": bool,
     "category": str,
     "products": list[dict],
     "spec_comparison": dict,
     "summary": str
   }
   
Endpoint 5: POST /evaluate
   Purpose: Evaluate summary quality
   
   Input:
   - reference_text: str (ground truth)
   - generated_text: str (generated summary)
   
   Output: EvaluationResponse
   {
     "scores": dict (ROUGE & BLEU scores),
     "report": str (formatted report)
   }
   
Endpoint 6: GET /dataset-info
   Purpose: Get dataset information
   
   Output:
   {
     "total_products": int,
     "categories": list[str],
     "products": list[dict]
   }
   
Endpoint 7: POST /train
   Purpose: Initiate model training
   
   Input: TrainingRequest
   {
     "num_epochs": int,
     "batch_size": int,
     "model_name": str
   }
   
   Output: TrainingResponse
   {
     "status": str,
     "message": str,
     "metrics": dict (optional)
   }

3.5 EVALUATION METRICS EXPLAINED
---------------------------------

A) ROUGE (Recall-Oriented Understudy for Gisting Evaluation)

ROUGE-1 (Unigram Overlap)
   Calculation:
   - Count overlapping words between generated and reference
   - Precision = (overlapping words) / (words in generated)
   - Recall = (overlapping words) / (words in reference)
   - F1 = 2 * (Precision * Recall) / (Precision + Recall)
   
   Example:
   Reference: "The laptop has great battery life"
   Generated: "The laptop features excellent battery"
   Overlap: "The", "laptop", "battery" (3 words)
   ROUGE-1 Recall: 3/6 = 0.50
   ROUGE-1 Precision: 3/5 = 0.60
   ROUGE-1 F1: 0.545

ROUGE-2 (Bigram Overlap)
   Measures overlap of two-word phrases
   More strict than ROUGE-1
   Better for evaluating fluency

ROUGE-L (Longest Common Subsequence)
   Finds longest sequence of words in order
   Allows gaps between words
   Measures sentence-level structure similarity

B) BLEU (Bilingual Evaluation Understudy)

Originally for machine translation, adapted for summarization

BLEU-1: Unigram precision
BLEU-2: Bigram precision
BLEU-4: Up to 4-gram precision

Calculation:
- Count n-gram matches
- Calculate precision for each n
- Multiply precisions and apply brevity penalty
- Penalizes very short summaries

3.6 TRAINING PIPELINE ARCHITECTURE
-----------------------------------

Training Process:

1. DATA PREPARATION
   - Load product dataset
   - Extract (description, summary) pairs
   - Split into train/validation sets (80/20)
   - Convert to HuggingFace Dataset format

2. TOKENIZATION
   - Tokenize inputs (max_length=1024)
   - Tokenize targets (max_length=256)
   - Add special tokens ([CLS], [SEP])
   - Create attention masks

3. MODEL SETUP
   - Load pre-trained BART model
   - Initialize optimizer (AdamW)
   - Set up learning rate scheduler
   - Configure mixed precision (FP16)

4. TRAINING LOOP
   For each epoch:
     For each batch:
       - Forward pass
       - Calculate loss (cross-entropy)
       - Backward pass (gradients)
       - Optimizer step
       - Update learning rate
       - Log metrics

5. EVALUATION
   - Run on validation set
   - Calculate ROUGE scores
   - Monitor overfitting
   - Save best checkpoint

6. SAVING
   - Save model weights
   - Save tokenizer
   - Save training configuration
   - Export metrics


================================================================================
              SECTION 4: IMPLEMENTATION DETAILS AND USAGE
================================================================================

4.1 INSTALLATION AND SETUP
---------------------------

Step 1: Environment Setup
   Requirements:
   - Python 3.8 or higher
   - pip package manager
   - Virtual environment (recommended)
   
   Commands:
   ```
   # Create virtual environment
   python -m venv venv
   
   # Activate (Windows)
   venv\Scripts\activate
   
   # Activate (Mac/Linux)
   source venv/bin/activate
   ```

Step 2: Install Dependencies
   ```
   pip install -r requirements.txt
   ```
   
   This installs all 19 required packages:
   - Web framework: FastAPI, Uvicorn
   - ML libraries: Transformers, PyTorch, LangChain
   - NLP tools: NLTK
   - Metrics: rouge-score, evaluate
   - Training: datasets, accelerate, peft
   - Utilities: pandas, scikit-learn, PyPDF2
   - Config: pydantic-settings, python-dotenv

Step 3: Download NLTK Data
   ```
   python -c "import nltk; nltk.download('punkt'); nltk.download('stopwords')"
   ```
   
   This downloads:
   - punkt: Sentence tokenizer
   - stopwords: Common words list

Step 4: Start Server
   ```
   uvicorn app.main:app --reload
   ```
   
   Options:
   - --reload: Auto-restart on file changes
   - --host 0.0.0.0: Allow network access
   - --port 8000: Custom port

Step 5: Access Application
   - Web UI: http://localhost:8000
   - API Docs: http://localhost:8000/docs
   - Health Check: http://localhost:8000/health

4.2 USING THE WEB INTERFACE
----------------------------

Tab 1: Technical Summary
   Purpose: Analyze single product
   
   Steps:
   1. Click "Technical Summary" tab
   2. Either:
      - Upload a PDF product description, OR
      - Paste text in the text area
   3. Click "Generate Technical Summary"
   4. Wait for processing (5-30 seconds)
   5. View structured output:
      - Product name and category
      - Summary paragraph
      - Key specifications grid
      - Pros (green box)
      - Cons (red box)
      - Best use case recommendation

Tab 2: Product Comparison
   Purpose: Compare 2-5 products
   
   Steps:
   1. Click "Product Comparison" tab
   2. Enter descriptions for Product 1 and Product 2
   3. (Optional) Click "+ Add Product" for more
   4. Click "Compare Products"
   5. View comparison results:
      - Comparison summary
      - Product cards (side-by-side)
      - Specification comparison table
      - Category and price information

Tab 3: Evaluation
   Purpose: Measure summary quality
   
   Steps:
   1. Click "Evaluation" tab
   2. Enter reference summary (ground truth)
   3. Enter generated summary (to evaluate)
   4. Click "Evaluate Quality"
   5. View metrics:
      - ROUGE-1, ROUGE-2, ROUGE-L scores
      - BLEU-1, BLEU-2, BLEU-4 scores
      - Overall quality score (percentage)
      - Detailed text report

Tab 4: Dataset & Training
   Purpose: View data and initiate training
   
   Steps:
   1. Click "Dataset & Training" tab
   2. Click "Load Dataset Info" to view:
      - Total products (6 sample products)
      - Categories (Laptop, Smartphone, Tablet, Monitor)
      - Product list
   3. Configure training:
      - Number of epochs (1-10)
      - Batch size (1-8)
   4. Click "Initiate Training"
   5. View training status (demo mode)

4.3 USING THE API PROGRAMMATICALLY
-----------------------------------

Example 1: Technical Summarization
   ```python
   import requests
   
   # Prepare data
   product_text = """
   The TechPro UltraBook features Intel Core i7, 32GB RAM,
   1TB SSD, 14-inch 4K display, weighs 1.3kg...
   """
   
   # Make request
   response = requests.post(
       "http://localhost:8000/technical-summarize",
       data={"text": product_text}
   )
   
   # Parse response
   result = response.json()
   print(f"Product: {result['product_name']}")
   print(f"Category: {result['category']}")
   print(f"Summary: {result['summary']}")
   print(f"Specs: {result['key_specs']}")
   ```

Example 2: Product Comparison
   ```python
   import requests
   
   products = [
       "Product 1 description...",
       "Product 2 description..."
   ]
   
   response = requests.post(
       "http://localhost:8000/compare-products",
       data={"texts": products}
   )
   
   result = response.json()
   print(f"Comparing {result['product_count']} products")
   print(f"Summary: {result['summary']}")
   ```

Example 3: Evaluation
   ```python
   import requests
   
   reference = "Original summary..."
   generated = "AI-generated summary..."
   
   response = requests.post(
       "http://localhost:8000/evaluate",
       data={
           "reference_text": reference,
           "generated_text": generated
       }
   )
   
   scores = response.json()['scores']
   print(f"ROUGE-1 F1: {scores['rouge1_fmeasure']:.4f}")
   print(f"BLEU-4: {scores['bleu4']:.4f}")
   ```

4.4 CUSTOMIZATION AND EXTENSION
--------------------------------

A) Adding New Product Categories
   Location: app/services/technical_summarizer.py
   Method: _determine_category()
   
   Add to categories dictionary:
   ```python
   categories = {
       'Laptop': ['laptop', 'notebook'],
       'Your_Category': ['keyword1', 'keyword2']
   }
   ```

B) Modifying Evaluation Metrics
   Location: app/evaluation/metrics.py
   Class: SummarizationEvaluator
   
   Add custom metric:
   ```python
   def evaluate_custom_metric(self, generated, reference):
       # Your metric calculation
       return score
   ```

C) Adding New Datasets
   Location: app/data/product_dataset.py
   
   Add product to sample data:
   ```python
   {
       "product_id": "new_001",
       "product_name": "Your Product",
       "category": "Category",
       "full_description": "...",
       "target_summary": {...}
   }
   ```

D) Changing the Model
   Location: app/services/technical_summarizer.py
   
   Modify initialization:
   ```python
   def __init__(self, model_name: str = "your-model-name"):
       # Load different model
   ```
   
   Compatible models:
   - facebook/bart-large-cnn (current)
   - t5-base
   - google/pegasus-xsum
   - Any Seq2Seq model from HuggingFace

4.5 TROUBLESHOOTING
-------------------

Issue 1: Model Download Slow
   Problem: First run downloads ~1.6GB model
   Solution: Be patient, only happens once
   Alternative: Pre-download model
   
Issue 2: Out of Memory
   Problem: Large texts cause memory issues
   Solution: Reduce batch size or max_length
   
Issue 3: Slow Inference
   Problem: CPU inference is slow
   Solution: Use GPU if available
   Check: torch.cuda.is_available()
   
Issue 4: Import Errors
   Problem: Missing dependencies
   Solution: pip install -r requirements.txt
   
Issue 5: NLTK Data Missing
   Problem: punkt or stopwords not found
   Solution: Run nltk.download() commands

4.6 PERFORMANCE OPTIMIZATION
-----------------------------

A) Speed Improvements
   - Use GPU for inference (10-50x faster)
   - Reduce beam_search beams (4 â†’ 2)
   - Lower max_length (200 â†’ 128)
   - Batch multiple requests

B) Memory Optimization
   - Use quantization (8-bit or 4-bit)
   - Enable gradient checkpointing
   - Reduce batch size
   - Clear cache: torch.cuda.empty_cache()

C) Accuracy Improvements
   - Fine-tune on domain-specific data
   - Increase beam_search beams
   - Use larger models (bart-large â†’ pegasus)
   - Ensemble multiple models

4.7 SECURITY CONSIDERATIONS
----------------------------

A) Input Validation
   - Maximum text length enforced
   - File type restrictions (PDF only)
   - File size limits
   - SQL injection prevention (not using SQL)

B) API Security
   - Add authentication (JWT tokens)
   - Rate limiting (prevent abuse)
   - CORS configuration (restrict origins)
   - HTTPS in production

C) Data Privacy
   - No data stored by default
   - Clear cache after processing
   - No logging of sensitive data
   - GDPR compliance ready

4.8 DEPLOYMENT GUIDE
--------------------

Development:
   ```
   uvicorn app.main:app --reload
   ```

Production:
   ```
   uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4
   ```
   
Docker Deployment:
   ```dockerfile
   FROM python:3.9
   WORKDIR /app
   COPY requirements.txt .
   RUN pip install -r requirements.txt
   RUN python -c "import nltk; nltk.download('punkt'); nltk.download('stopwords')"
   COPY . .
   CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
   ```

Cloud Deployment Options:
   - AWS: EC2, Lambda, ECS
   - Google Cloud: Cloud Run, Compute Engine
   - Azure: App Service, Container Instances
   - Heroku: Container deployment

4.9 DATASET DETAILS
-------------------

Built-in Dataset:
   Products: 6 technical products
   Categories: Laptop, Smartphone, Tablet, Monitor
   
   Structure per product:
   - product_id: Unique identifier
   - product_name: Full product name
   - category: Product category
   - full_description: 200-400 word description
   - target_summary: Structured summary with:
     * product_name
     * category
     * key_specs (dict)
     * pros (list)
     * cons (list)
     * best_for (str)
     * price_range (str)

   Products included:
   1. TechPro UltraBook X1 (Premium Laptop)
   2. BudgetTech Essential 15 (Budget Laptop)
   3. PhoneMax Pro 14 (Premium Smartphone)
   4. ValuePhone A52 (Mid-range Smartphone)
   5. ProTab Studio 12 (Premium Tablet)
   6. DisplayMaster 4K Pro 32 (Professional Monitor)

4.10 FUTURE ENHANCEMENTS
------------------------

Planned Features:
   - Multi-language support
   - Image analysis from product images
   - Real-time price comparison integration
   - User review sentiment analysis
   - Export to PDF/CSV formats
   - API rate limiting and authentication
   - Caching for faster responses
   - Background job processing
   - Email notification system
   - Advanced analytics dashboard

Technical Improvements:
   - Async training pipeline
   - Model quantization for faster inference
   - LoRA fine-tuning implementation
   - Retrieval-augmented generation (RAG)
   - Multi-modal analysis (text + images)
   - Graph neural networks for spec comparison
   - Active learning for dataset expansion

================================================================================
                              END OF DOCUMENTATION
================================================================================

For support, issues, or contributions, please refer to the project repository.

Last Updated: 2024
Version: 1.0

